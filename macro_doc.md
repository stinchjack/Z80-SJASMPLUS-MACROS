# Z80 Macro Documentation

## File: `8-bit-conditional-branch.macro.asm`

| Macro Name | Parameters | Side Effects | Usage | Z80 Equivalent | Notes |
|------------|------------|---------------|--------|----------------|-------|
| BRANCH_IF_A_EQU |  |  |  |  | ============================================================================<br>Z80 8-bit Conditional Branching Macros for SJASMPlus<br>Author: Jack Stinchcombe<br>License: MIT<br><br>Description:<br>  A collection of assembly macros for Z80 8-bit conditional branching and<br>  flow control using SJASMPlus syntax. These macros encapsulate conditional<br>  logic based on comparisons of register A and memory values.<br><br>  Include this file in your SJASMPlus project using:<br>    INCLUDE "8-bit-conditional-branch.macro.asm"<br>============================================================================<br>----------------------------------------------------------------------------<br>BRANCH_IF_A_EQU val, address<br>Branches to 'address' if A == val<br>---------------------------------------------------------------------------- |
| BRANCH_IF_A_NOT_EQU |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_IF_A_NOT_EQU val, address<br>Branches to 'address' if A != val<br>---------------------------------------------------------------------------- |
| BRANCH_HLPTR_EQU |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_HLPTR_EQU val, addr<br>Branches to 'addr' if (HL) == val<br>Uses up A register<br>---------------------------------------------------------------------------- |
| BRANCH_HLPTR_NOT_EQU |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_HLPTR_NOT_EQU val, addr<br>Branches to 'addr' if (HL) != val<br>---------------------------------------------------------------------------- |
| BRANCH_UNSIGNED_A_LTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_UNSIGNED_A_LTE_V v, dest<br>Branches to 'dest' if A <= v (unsigned comparison)<br>---------------------------------------------------------------------------- |
| BRANCH_UNSIGNED_A_LT_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_UNSIGNED_A_LT_V v, dest<br>Branches to 'dest' if A < v (unsigned comparison)<br>---------------------------------------------------------------------------- |
| BRANCH_UNSIGNED_A_GTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_UNSIGNED_A_GTE_V v, dest<br>Branches to 'dest' if A >= v (unsigned comparison)<br>---------------------------------------------------------------------------- |
| BRANCH_UNSIGNED_A_GT_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_UNSIGNED_A_GT_V v, dest<br>Branches to 'dest' if A > v (unsigned comparison)<br>---------------------------------------------------------------------------- |
| RET_UNSIGNED_A_LTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>RET_UNSIGNED_A_LTE_V v<br>Returns if A <= v (unsigned)<br>---------------------------------------------------------------------------- |
| RET_UNSIGNED_A_LT_V |  |  |  |  | ----------------------------------------------------------------------------<br>RET_UNSIGNED_A_LT_V v<br>Returns if A < v (unsigned)<br>---------------------------------------------------------------------------- |
| RET_UNSIGNED_A_GTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>RET_UNSIGNED_A_GTE_V v<br>Returns if A >= v (unsigned)<br>---------------------------------------------------------------------------- |
| RET_UNSIGNED_A_GT_V |  |  |  |  | ----------------------------------------------------------------------------<br>RET_UNSIGNED_A_GT_V v<br>Returns if A > v (unsigned)<br>---------------------------------------------------------------------------- |
| CALL_UNSIGNED_A_LTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>CALL_UNSIGNED_A_LTE_V v, dest<br>Calls 'dest' if A <= v (unsigned)<br>---------------------------------------------------------------------------- |
| CALL_UNSIGNED_A_LT_V |  |  |  |  | ----------------------------------------------------------------------------<br>CALL_UNSIGNED_A_LT_V v, dest<br>Calls 'dest' if A < v (unsigned)<br>---------------------------------------------------------------------------- |
| CALL_UNSIGNED_A_GTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>CALL_UNSIGNED_A_GTE_V v, dest<br>Calls 'dest' if A >= v (unsigned)<br>---------------------------------------------------------------------------- |
| CALL_UNSIGNED_A_GT_V |  |  |  |  | ----------------------------------------------------------------------------<br>CALL_UNSIGNED_A_GT_V v, dest<br>Calls 'dest' if A > v (unsigned)<br>---------------------------------------------------------------------------- |
| BRANCH_SIGNED_A_GT_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_SIGNED_A_GT_V v, dest<br>Branches to 'dest' if A > v (signed comparison)<br>---------------------------------------------------------------------------- |
| BRANCH_SIGNED_A_GTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_SIGNED_A_GTE_V v, dest<br>Branches to 'dest' if A >= v (signed comparison)<br>---------------------------------------------------------------------------- |
| BRANCH_SIGNED_A_LT_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_SIGNED_A_LT_V v, dest<br>Branches to 'dest' if A < v (signed comparison)<br>---------------------------------------------------------------------------- |
| BRANCH_SIGNED_A_LTE_V |  |  |  |  | ----------------------------------------------------------------------------<br>BRANCH_SIGNED_A_LTE_V v, dest<br>Branches to 'dest' if A <= v (signed comparison)<br>---------------------------------------------------------------------------- |

## File: `8-bit-maths.macros.asm`

| Macro Name | Parameters | Side Effects | Usage | Z80 Equivalent | Notes |
|------------|------------|---------------|--------|----------------|-------|
| MIN_UNSIGNED_A_VAL |  |  |  |  | ============================================================================<br>Z80 8-bit Arithmetic Macros for SJASMPlus<br>Author: Jack Stinchcombe<br>License: MIT<br><br>Description:<br>  A collection of assembly macros for Z80 8-bit arithmetic operations using<br>  SJASMPlus syntax. These macros simplify common patterns for manipulating<br>  8-bit values in registers and memory.<br><br>  INCLUDE "8-bit-maths-macros.inc"<br><br>Key Points:<br>These macros work only on 8-bit values<br><br>Some macros modify register A and flags<br><br>Macros using IX offsets assume signed offsets (-128..127)<br><br>ADD_ADDR_REG does NOT accept A as reg parameter<br>============================================================================<br>----------------------------------------------------------------------------<br>MIN_UNSIGNED_A_VAL val<br>----------------------<br>  val - immediate 8-bit unsigned constant<br><br>Description:<br>  Clamp register A to a minimum value (A = max(A, val)).<br>  If A < val, then A is set to val.<br><br>  Modifies register A and flags (AF register pair).<br><br>  MIN_UNSIGNED_A_VAL 42<br>---------------------------------------------------------------------------- |
| MAX_UNSIGNED_A_VAL |  |  |  |  | ----------------------------------------------------------------------------<br>MAX_UNSIGNED_A_VAL val<br>----------------------<br>  val - immediate 8-bit unsigned constant<br><br>Description:<br>  Clamp register A to a maximum value (A = min(A, val)).<br>  If A > val, then A is set to val.<br><br>  Modifies register A and flags (AF register pair).<br><br><br>  MAX_UNSIGNED_A_VAL 200<br>---------------------------------------------------------------------------- |
| ADD_ADDR_REG |  |  |  |  | ----------------------------------------------------------------------------<br>ADD_ADDR_REG addr, reg<br>----------------------<br>  addr - memory address (label or direct)<br>  reg  - 8-bit register (not A)<br><br>Description:<br>  Adds the value of register 'reg' to the byte at memory location 'addr'.<br>  (addr) += reg. Does NOT work with A register<br><br>  Modifies register A and flags.<br><br>  add (addr), r<br><br>  ADD_ADDR_REG myVar, b<br>---------------------------------------------------------------------------- |
| ADD_ADDR_ADDR |  |  |  |  | ----------------------------------------------------------------------------<br>ADD_ADDR_ADDR addr1, addr2<br>--------------------------<br>  addr1 - destination memory address<br>  addr2 - source memory address<br><br>Description:<br>  Adds the byte at addr2 to the byte at addr1 and stores the result in addr1.<br>  (addr1) += (addr2)<br><br>  Uses register A and HL; pushes and pops HL.<br><br>  add (addr1), (addr2)<br><br>  ADD_ADDR_ADDR var1, var2<br>---------------------------------------------------------------------------- |
| ADD_IX |  |  |  |  | ----------------------------------------------------------------------------<br>ADD_IX idx1, idx2<br>-----------------<br>  idx1 - IX offset destination (signed 8-bit)<br>  idx2 - IX offset source (signed 8-bit)<br><br>Description:<br>  Adds the value at (IX + idx2) to the value at (IX + idx1).<br>  (IX+idx1) += (IX+idx2)<br><br>  Modifies register A and flags.<br><br>  add (ix+idx1), (ix+idx2)<br><br>  ADD_IX 0, 1<br>---------------------------------------------------------------------------- |
| SUM_IX |  |  |  |  | ----------------------------------------------------------------------------<br>SUM_IX idx1, idx2, idx3<br>-----------------------<br>  idx1 - IX offset destination (signed 8-bit)<br>  idx2 - IX offset source 1 (signed 8-bit)<br>  idx3 - IX offset source 2 (signed 8-bit)<br><br>Description:<br>  Computes the sum of bytes at (IX+idx2) and (IX+idx3) and stores it in (IX+idx1).<br>  (IX+idx1) = (IX+idx2) + (IX+idx3)<br><br>  Modifies register A and flags.<br><br>  ld (ix+idx1), (ix+idx2)<br>  add (ix+idx3)<br><br>  SUM_IX 0, 1, 2<br>---------------------------------------------------------------------------- |
| NEG8_IXPLUS |  |  |  |  | ----------------------------------------------------------------------------<br>NEG8_IXPLUS n<br>-------------<br>  n - signed 8-bit IX offset<br><br>Description:<br>  Negates the value at (IX + n).<br>  (IX+n) = - (IX+n)<br><br>  Uses registers A and flags.<br><br><br>  NEG8_IXPLUS -3<br>---------------------------------------------------------------------------- |
| ABS8_IXPLUS |  |  |  |  | ----------------------------------------------------------------------------<br>ABS8_IXPLUS n<br>-------------<br>  n - signed 8-bit IX offset<br><br>Description:<br>  Replaces the value at (IX+n) with its absolute value (treating it as signed).<br>  (IX+n) = abs((IX+n))<br><br>  Uses registers A and flags.<br><br><br>  ABS8_IXPLUS 5<br>---------------------------------------------------------------------------- |
| ABS8_A |  |  |  |  | ----------------------------------------------------------------------------<br>ABS8_A<br>-------<br>  none<br><br>Description:<br>  Converts register A to its absolute value (if signed).<br><br>  Modifies register A and flags.<br><br><br>  ABS8_A<br>---------------------------------------------------------------------------- |
| ABS8_HLPTR |  |  |  |  | ----------------------------------------------------------------------------<br>ABS8_HLPTR<br>----------<br>  none<br><br>Description:<br>  Converts the byte pointed to by HL to its absolute value (if signed).<br>  (HL) = abs((HL))<br><br>  Uses register A and flags.<br><br><br>  ABS8_HLPTR<br>---------------------------------------------------------------------------- |
| ABS8_DEPTR |  |  |  |  | ----------------------------------------------------------------------------<br>ABS8_DEPTR<br>----------<br>  none<br><br>Description:<br>  Converts the byte pointed to by DE to its absolute value (if signed).<br>  (DE) = abs((DE))<br><br>  Uses registers A and HL; swaps HL and DE temporarily.<br>  Uses flags.<br><br>  ABS8_DEPTR<br>---------------------------------------------------------------------------- |

## File: `sjasmplus-macros.inc.asm`

_No macros found._

